/// Represents a user's record or note about a specific track.
import 'package:flutter/foundation.dart';

class Record {
  final int? id; // Nullable for new records not yet saved
  final String trackId;
  final String? noteContent;
  final int? rating; // Changed from String? to int?
  final int? songTimestampMs;
  final int recordedAt; // Store as milliseconds since epoch
  final String? contextUri;
  final String? contextName;
  final String? lyricsSnapshot; // Optional: Store relevant lyrics part

  Record({
    this.id,
    required this.trackId,
    this.noteContent,
    this.rating, // Changed from String? to int?
    this.songTimestampMs,
    required this.recordedAt,
    this.contextUri,
    this.contextName,
    this.lyricsSnapshot,
  });

  /// Creates a Record instance from a map (e.g., from SQFlite query).
  factory Record.fromMap(Map<String, dynamic> map) {
    // Basic validation or default values can be added here if needed
    // For example, ensuring required fields are present
    if (map['trackId'] == null || map['recordedAt'] == null) {
       debugPrint('Error creating Record from map: $map');
      throw ArgumentError('Required fields trackId or recordedAt missing in map');
    }

    return Record(
      id: map['id'] as int?, // Allow id to be null from map
      trackId: map['trackId'] as String,
      noteContent: map['noteContent'] as String?,
      rating: map['rating'] as int?, // Changed from String? to int?
      songTimestampMs: map['songTimestampMs'] as int?,
      recordedAt: map['recordedAt'] as int,
      contextUri: map['contextUri'] as String?,
      contextName: map['contextName'] as String?,
      lyricsSnapshot: map['lyricsSnapshot'] as String?,
    );
  }

  /// Converts this Record instance into a map (e.g., for SQFlite insertion).
  /// Excludes 'id' because it's auto-generated by the database.
  Map<String, dynamic> toMap() {
    return {
      'id': id, // id will be handled by the database
      'trackId': trackId,
      'noteContent': noteContent,
      'rating': rating, // Changed from String? to int?
      'songTimestampMs': songTimestampMs,
      'recordedAt': recordedAt,
      'contextUri': contextUri,
      'contextName': contextName,
      'lyricsSnapshot': lyricsSnapshot,
    };
  }

  @override
  String toString() {
    return 'Record{id: $id, trackId: $trackId, rating: $rating, recordedAt: $recordedAt, note: $noteContent}';
  }

  // Optional: Implement equality operator and hashCode if needed for comparisons
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Record &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          trackId == other.trackId &&
          rating == other.rating && // Changed from String? to int?
          recordedAt == other.recordedAt; // Compare relevant fields

  @override
  int get hashCode => id.hashCode ^ trackId.hashCode ^ rating.hashCode ^ recordedAt.hashCode; // Combine relevant fields
} 